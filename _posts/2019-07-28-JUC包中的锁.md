---
layout: post
title: JUC包中的锁
date: 2019-07-28 17:22:04 +0800
excerpt: 这篇博客介绍了JUC包中锁的实现原理，也是《Java并发编程的艺术》第五章读书笔记。
author: 霜月初六
img:  juc.png 
tags: [Java]
---

## JUC包中的锁

### 一、Lock接口

Lock提供了与synchronized关键字类似的同步功能，前者比后者使用上更加灵活、便捷，还提供了可中断获取锁、可超时获取锁的同步特性，这是后者不具有的。

Lock的使用：

```java
Lock lock = new ReentrantLock();
lock.lock();	// 最好写在try语句外，防止获取锁时抛出异常，导致锁无法被释放
try{
}finally(){
    lock.unlock();	// 一定要在finally中，确保锁最终能够被释放
}
```

Lock接口有两个非常重要的实现类，通常也是使用这两个实现类实现锁的功能

- ReentrantLock：可重入锁

- ReentrantReadWriteLock：读写锁，也是可重入锁。内部有两个静态内部类，都实现了Lock接口

- ```java
  /** Inner class providing readlock */
  private final ReentrantReadWriteLock.ReadLock readerLock;
  public static class ReadLock implements Lock, java.io.Serializable{}
  /** Inner class providing writelock */
  private final ReentrantReadWriteLock.WriteLock writerLock;
  public static class WriteLock implements Lock, java.io.Serializable {}
  ```

在介绍锁之前，需要介绍**队列同步器（AbstractQueuedSynchronizer）**，它是用来构建锁和其它同步组件的基础框架。



### 二、队列同步器（AQS）

AQS使用一个**int型变量**表示**同步状态**，通过FIFO队列实现线程的同步等待队列。

AQS的设计是基于模板方法模式的，通过设计一些**原语操作**供子类实现，提供模板方法供子类调用。这样**子类就可以忽略父类的具体结构，专注实现与自身相关的算法即可**。AQS的子类被推荐定义为同步组件的静态内部类，同步器自身没有实现任何接口，只是定义了若干同步状态获取和释放的方法以供使用。







> 本文首发于我的个人网站【[https://mrxwte.github.io](https://mrxwte.github.io/)】，转载请注明出处。